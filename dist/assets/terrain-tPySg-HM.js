import{P as D,M as G,a as S,C as w,F as b,b as k,c as q,G as F}from"./main-B6IneKfK.js";class X{constructor(e,i,t){if(!e)throw new Error("Scene is required for Terrain");this.scene=e,this.modelManager=i,this.holeConfig=t,this.width=t.width,this.depth=t.depth,this.resolution=t.resolution,this.geometry=new D(this.width,this.depth,this.resolution,this.resolution),this.geometry.rotateX(-Math.PI/2),this.material=new G({vertexColors:!0,flatShading:!0,roughness:.8,metalness:.1}),this.mesh=new S(this.geometry,this.material),this.mesh.receiveShadow=!0,this.mesh.castShadow=!0,this.heightMap=[],this.surfaceMap=[],this.generateTerrain()}generateTerrain(){const e=this.geometry.attributes.position,i=[],{tee:t,green:o,fairway:n,bunkers:s,trees:h}=this.holeConfig,l=20;this.heightMap=[],this.surfaceMap=[];for(let c=0;c<e.count;c++){const a=e.getX(c),r=e.getZ(c);let u,d,g;const x=a-o.x,y=r-o.z,m=Math.sqrt(x*x+y*y),v=Math.sin(a*.05)*3+Math.cos(r*.05)*3+Math.sin(a*.1+r*.1)*2,T=Math.sin(a*.01)*2+Math.cos(r*.02)*1.5;if(s.some(M=>{const p=a-M.x,f=r-M.z;return Math.sqrt(p*p+f*f)<M.radius}))u=-1,d=new w(15124885),g="bunker";else if(m<o.radius){if(m>o.radius-4){const f=this.smoothstep(0,1,(o.radius-m)/4);u=o.elevation-(o.elevation-f)*.3}else u=o.elevation;const p=(Math.floor(a*2)+Math.floor(r*2))%2===0;d=new w(p?"#8eff8e":"#77dd77"),g="green"}else if(a>t.x-l/2&&a<t.x+l/2&&r>t.z-l/2&&r<t.z+l/2)u=t.elevation,d=new w("#328a58"),g="tee";else if(this.isNearPath(a,r,n.path,n.width)){const M=this.getDistanceFromPath(a,r,n.path),p=n.width*.4;if(M<p)u=T*.3;else{const f=(M-p)/(n.width/2-p),z=this.smoothstep(0,1,f);u=T*.3*(1-z)+v*z}d=new w("#5cb762"),g="fairway"}else u=v,d=new w("#2a4e30"),g="rough";e.setY(c,u),this.heightMap.push(u),this.surfaceMap.push(g),i.push(d.r,d.g,d.b)}e.needsUpdate=!0,this.geometry.setAttribute("color",new b(i,3)),this.geometry.computeVertexNormals(),h&&h.positions&&h.positions.forEach(c=>{this.addTree(c.x,c.z)})}createHole(e,i){const s=this.geometry.attributes.position.array;for(let h=0;h<s.length;h+=3){const l=s[h],c=s[h+2],a=Math.sqrt((l-e)**2+(c-i)**2);if(a<.3){s[h+1]-=.5;const r=h/3;r<this.heightMap.length&&(this.heightMap[r]-=.5)}else if(a<.5){const r=(a-.3)/.2,d=.5*(1-r*r*(3-2*r));s[h+1]-=d;const g=h/3;g<this.heightMap.length&&(this.heightMap[g]-=d)}}this.geometry.computeVertexNormals(),this.geometry.attributes.position.needsUpdate=!0}getHeightAt(e,i){const t=this.width/2,o=this.depth/2;if(e<-t||e>t||i<-o||i>o)return 0;const n=Math.floor((e+t)/this.width*this.resolution),s=Math.floor((i+o)/this.depth*this.resolution),h=(e+t)/this.width*this.resolution-n,l=(i+o)/this.depth*this.resolution-s,c=this.resolution+1,a=s*c+n,r=s*c+Math.min(n+1,this.resolution),u=Math.min(s+1,this.resolution)*c+n,d=Math.min(s+1,this.resolution)*c+Math.min(n+1,this.resolution),g=a>=0&&a<this.heightMap.length?this.heightMap[a]:0,x=r>=0&&r<this.heightMap.length?this.heightMap[r]:0,y=u>=0&&u<this.heightMap.length?this.heightMap[u]:0,m=d>=0&&d<this.heightMap.length?this.heightMap[d]:0,v=g*(1-h)+x*h,T=y*(1-h)+m*h;return v*(1-l)+T*l}getSurfaceTypeAt(e,i){const t=this.width/2,o=this.depth/2;if(e<-t||e>t||i<-o||i>o)return"rough";const n=Math.floor((e+t)/this.width*this.resolution),s=Math.floor((i+o)/this.depth*this.resolution),h=this.resolution+1,l=s*h+n;return l>=0&&l<this.surfaceMap.length?this.surfaceMap[l]:"rough"}createGolfHole(e,i){this.createHole(e,i)}isNearPath(e,i,t,o){for(let n=0;n<t.length-1;n++){const s=t[n],h=t[n+1],l=h.x-s.x,c=h.z-s.z,a=Math.sqrt(l*l+c*c);if(a===0)continue;const r=Math.max(0,Math.min(1,((e-s.x)*l+(i-s.z)*c)/(a*a))),u=s.x+r*l,d=s.z+r*c;if(Math.sqrt((e-u)*(e-u)+(i-d)*(i-d))<o/2)return!0}return!1}getDistanceFromPath(e,i,t){let o=1/0;for(let n=0;n<t.length-1;n++){const s=t[n],h=t[n+1],l=h.x-s.x,c=h.z-s.z,a=Math.sqrt(l*l+c*c);if(a===0)continue;const r=Math.max(0,Math.min(1,((e-s.x)*l+(i-s.z)*c)/(a*a))),u=s.x+r*l,d=s.z+r*c,g=Math.sqrt((e-u)*(e-u)+(i-d)*(i-d));o=Math.min(o,g)}return o}smoothstep(e,i,t){return t=Math.max(0,Math.min(1,(t-e)/(i-e))),t*t*(3-2*t)}addTree(e,i){if(!this.scene)return;const t=this.getHeightAt(e,i),o=this.createTree();o.position.set(e,t,i),this.scene.add(o)}createTree(){const e=new k(.8,1.2,6,8),i=new q(3.5,7,8),t=new G({color:9127187,roughness:.9,metalness:0}),o=new G({color:2263842,roughness:.7,metalness:0}),n=new S(e,t);n.castShadow=!0,n.receiveShadow=!0;const s=new S(i,o);s.castShadow=!0,s.receiveShadow=!0,s.position.y=6;const h=new F;return h.add(n),h.add(s),h}}export{X as Terrain};
