import{V as o,d as r}from"./main-B6IneKfK.js";class d{constructor(){this.gravity=10,this.friction={fairway:80,rough:75,green:1},this.clubStats={driver:{angle:15,multiplier:3.5},iron:{angle:35,multiplier:2.1},wedge:{angle:55,multiplier:.8},putter:{angle:5,multiplier:.5}},this.ball={position:new o,velocity:new o,inAir:!1,onGround:!1},this.hole={position:new o(250,0,0),radius:.3},this.wind={speed:10,direction:Math.PI/4,updateInterval:2,lastUpdate:0,forceScale:.1},this.terrain=null,this.clubDistancesCache=null,this.maxPower=20}setTerrain(t){this.terrain=t}setHolePosition(t){this.hole.position.copy(t)}calculateClubDistances(){if(this.clubDistancesCache)return this.clubDistancesCache;console.log("Calculating club distances using formula...");const t={},i=Object.keys(this.clubStats),l=70;for(const s of i){const e=this.clubStats[s],n=r.degToRad(e.angle),a=Math.cos(n);t[s]=Math.round(e.multiplier*l*a),console.log(`${s}: distance = ${t[s]} units (multiplier: ${e.multiplier}, angle: ${e.angle}Â°)`)}return this.clubDistancesCache=t,t}precomputeClubDistances(){this.clubDistancesCache=null;const t=this.calculateClubDistances();console.log("Club distances calculated:",t),console.log("Relative distances:",{"driver/iron":(t.driver/t.iron).toFixed(1),"iron/wedge":(t.iron/t.wedge).toFixed(1),"wedge/putter":(t.wedge/t.putter).toFixed(1)})}getTerrainHeightAt(t,i){if(!this.terrain)return console.warn("Terrain not set in physics engine"),0;if(isNaN(t)||isNaN(i)||Math.abs(t)>500||Math.abs(i)>500)return console.warn("Invalid coordinates for terrain height:",t,i),0;try{return this.terrain.getHeightAt(t,i)}catch(l){return console.error("Error in terrain height finding:",l),0}}calculateShot(t,i,l){t<1&&(t=1);const s=this.clubStats[l]||this.clubStats.driver,e=r.degToRad(s.angle),n=t*s.multiplier,a=n*Math.cos(e),h=n*Math.sin(e);return this.ball.velocity=new o(a*Math.cos(i),h,a*-Math.sin(i)),this.ball.inAir=!0,this.ball.onGround=!1,this.ball.spin=.1,this.ball.position.y+=.05,!0}updateWind(t){t-this.wind.lastUpdate>this.wind.updateInterval&&(this.wind.direction+=(Math.random()-.5)*Math.PI/8,this.wind.speed=Math.max(5,Math.min(20,this.wind.speed+(Math.random()-.5)*5)),this.wind.lastUpdate=t)}getWindForce(){return new o(Math.cos(this.wind.direction)*this.wind.speed*this.wind.forceScale,0,Math.sin(this.wind.direction)*this.wind.speed*this.wind.forceScale)}update(t){const i=performance.now()/1e3;if(this.updateWind(i),!this.ball.inAir&&!this.ball.onGround&&this.ball.velocity.length()>0&&(console.log("Ball state corrected: setting to in-air"),this.ball.inAir=!0),this.ball.inAir){this.ball.velocity.y-=this.gravity*t;const s=this.getWindForce();this.ball.velocity.x+=s.x*t,this.ball.velocity.z+=s.z*t,this.ball.position.x+=this.ball.velocity.x*t,this.ball.position.y+=this.ball.velocity.y*t,this.ball.position.z+=this.ball.velocity.z*t;const e=this.getTerrainHeightAt(this.ball.position.x,this.ball.position.z);this.ball.position.y<e&&this.handleTerrainCollision(e)}else if(this.ball.onGround&&this.ball.velocity.length()>.01){this.ball.position.x+=this.ball.velocity.x*t,this.ball.position.z+=this.ball.velocity.z*t;const s=this.getTerrainHeightAt(this.ball.position.x,this.ball.position.z);this.ball.position.y=s;const e=this.getTerrainFriction(this.ball.position);this.ball.velocity.x*=e,this.ball.velocity.z*=e,this.ball.velocity.length()<.01&&this.ball.velocity.set(0,0,0)}if(Math.sqrt(Math.pow(this.ball.position.x-this.hole.position.x,2)+Math.pow(this.ball.position.z-this.hole.position.z,2))<this.hole.radius*2&&this.ball.velocity.length()<.4){const s=new o().subVectors(this.hole.position,this.ball.position);s.y=0,s.normalize().multiplyScalar(.02),this.ball.velocity.add(s)}}handleTerrainCollision(t){this.ball.position.y=t,this.ball.velocity.y*=-.3;const i=this.getTerrainFriction(this.ball.position);this.ball.velocity.x*=i,this.ball.velocity.z*=i,Math.abs(this.ball.velocity.y)<1&&(this.ball.velocity.y=0,this.ball.inAir=!1,this.ball.onGround=!0)}getTerrainFriction(t){if(!this.terrain)return .95;switch(this.terrain.getSurfaceTypeAt(t.x,t.z)){case"green":return .99;case"fairway":return .95;case"rough":return .9;case"bunker":return .85;default:return .95}}isBallInHole(){if(!this.ball||!this.hole)return!1;const t=this.ball.position.x-this.hole.position.x,i=this.ball.position.z-this.hole.position.z;return Math.sqrt(t*t+i*i)<this.hole.radius&&this.ball.velocity.length()<.5&&Math.abs(this.ball.position.y-this.hole.position.y)<.5}getIdealPowerForDistance(t,i){this.clubDistancesCache||this.calculateClubDistances();const l=this.clubDistancesCache[i];if(!l)return console.warn(`Club ${i} not found in distance data, using fallback`),this.maxPower/2;const s=t/l;return Math.min(this.maxPower,s*this.maxPower)}getDistanceToHole(){if(!this.ball||!this.hole)return 100;const t=Math.sqrt(Math.pow(this.ball.position.x-this.hole.position.x,2)+Math.pow(this.ball.position.z-this.hole.position.z,2));return Math.max(.1,t)}getIdealPowerToHole(t){const i=this.getDistanceToHole(),l=this.getIdealPowerForDistance(i,t);return console.log(`Club: ${t}, Distance to hole: ${i.toFixed(1)}, Ideal power: ${(l/this.maxPower*100).toFixed(0)}%`),l}}export{d as PhysicsEngine};
