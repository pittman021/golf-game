const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/terrain-tPySg-HM.js","assets/main-B6IneKfK.js","assets/physics-DaA4PKXM.js","assets/camera--MmAMCXv.js","assets/models-yiP8qoVj.js","assets/ui-wEGnrwR7.js"])))=>i.map(i=>d[i]);
import{_ as z}from"./main-B6IneKfK.js";let a,g,c,e,R,w,r,s,u,S,C=!1,h=0,B=!0,_=!1,v=0,I=!0,X=.02,E=1,L=4,b=0,D=!1,T=0,l,m=!1,Y=!1,G=!1,q=!1,V=null,N;function ee(){window.gameObjects={scene:a,camera:g,renderer:c,terrain:u,ball:s,cameraController:w,physicsEngine:e},console.log("Debug objects exposed to window.gameObjects")}async function ae(){try{console.log("Loading modules...");const t=await z(()=>import("./terrain-tPySg-HM.js"),__vite__mapDeps([0,1])),i=await z(()=>import("./physics-DaA4PKXM.js"),__vite__mapDeps([2,1])),n=await z(()=>import("./camera--MmAMCXv.js"),__vite__mapDeps([3,1])),o=await z(()=>import("./models-yiP8qoVj.js"),__vite__mapDeps([4,1])),d=await z(()=>import("./ui-wEGnrwR7.js"),__vite__mapDeps([5,1])),f=await z(()=>import("./holeConfigs-BNKkqUZn.js"),[]);re(t.Terrain,i.PhysicsEngine,n.CameraController,o.ModelManager,d.UIManager,f.holeConfigs)}catch(t){console.error("Error loading modules:",t)}}function re(t,i,n,o,d,f){N=t,window.holeConfigs=f,e=new i,window.physicsEngine=e,a=new THREE.Scene,window.debugScene=a;const x=new THREE.AmbientLight(8950960,.3);a.add(x);const p=new THREE.DirectionalLight(16767876,1);p.position.set(-1,1.2,.5),p.castShadow=!0,p.shadow.mapSize.width=4096,p.shadow.mapSize.height=4096,p.shadow.camera.near=.5,p.shadow.camera.far=500,p.shadow.camera.left=-100,p.shadow.camera.right=100,p.shadow.camera.top=100,p.shadow.camera.bottom=-100,p.shadow.bias=-1e-4,a.add(p);const P=new THREE.DirectionalLight(13821695,.3);P.position.set(1,.7,-.5),P.castShadow=!1,a.add(P),le(a),R=new o(a),u=new t(a,R,f[1]),window.debugTerrain=u,a.add(u.mesh);const J=new THREE.BufferGeometry,k=new THREE.LineBasicMaterial({color:16776960,linewidth:2,transparent:!0,opacity:.5});l=new THREE.Line(J,k),a.add(l),w=new n(a),g=w.camera,window.debugCamera=g,typeof w.initialize=="function"&&w.initialize(),c=new THREE.WebGLRenderer({antialias:!0}),window.debugRenderer=c,c.setSize(window.innerWidth,window.innerHeight),c.shadowMap.enabled=!0,c.shadowMap.type=THREE.PCFSoftShadowMap,(document.getElementById("app-container")||document.body).appendChild(c.domElement),c.domElement.style.display="block",c.domElement.style.width="100%",c.domElement.style.height="100%",c.domElement.style.position="absolute",c.domElement.style.top="0",c.domElement.style.left="0",c.domElement.style.zIndex="0",s=R.createBall(),r=new d,r.updateHoleInfo(E,L,b),r.setPhysicsEngine(e),window.addEventListener("resize",te),document.addEventListener("keydown",oe),document.addEventListener("keyup",ie),se(),K(),ee()}window.addEventListener("load",ae);function le(t){const i=new THREE.BoxGeometry(1e3,1e3,1e3),n=new THREE.ShaderMaterial({uniforms:{topColor:{value:new THREE.Color(21964)},bottomColor:{value:new THREE.Color(16772829)}},vertexShader:`
            varying vec3 vWorldPosition;
            void main() {
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,fragmentShader:`
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), 0.6), 0.0)), 1.0);
            }
        `,side:THREE.BackSide}),o=new THREE.Mesh(i,n);t.add(o)}function se(){console.log("Completing initialization..."),e.setTerrain(u),console.log("Physics engine connected to terrain"),U(1),window.addEventListener("resize",te),document.addEventListener("keydown",oe),document.addEventListener("keyup",ie),K(),ee()}function U(t){V&&(clearTimeout(V),V=null);const i=holeConfigs[t];if(!i){console.error(`Hole ${t} configuration not found`);return}E=t,L=i.par,b=0,q=!1,u&&a.remove(u.mesh),S&&a.remove(S),s&&a.remove(s),u=new N(a,R,i),a.add(u.mesh);const n=new THREE.Vector3(i.tee.x,u.getHeightAt(i.tee.x,i.tee.z)+.5,i.tee.z),o=new THREE.Vector3(i.green.x,u.getHeightAt(i.green.x,i.green.z),i.green.z);u.createHole(o.x,o.z),T=Math.atan2(o.z-n.z,o.x-n.x);const d=new THREE.Vector3(-8,8,0).applyAxisAngle(new THREE.Vector3(0,1,0),T);if(g.position.copy(n).add(d),w.targetPosition.copy(g.position),g.lookAt(o.x,o.y+.5,o.z),w.targetLookAt.set(o.x,o.y+.5,o.z),s=R.createBall(),s.position.copy(n),a.add(s),S=R.createFlagPin(o.x,o.z,u.getHeightAt.bind(u)),e.setTerrain(u),e.setHolePosition(o),e.ball.position.copy(s.position),e.ball.velocity.set(0,0,0),e.ball.inAir=!1,e.ball.onGround=!0,!l){const f=new THREE.BufferGeometry,x=new THREE.LineBasicMaterial({color:16776960,linewidth:2,transparent:!0,opacity:.5});l=new THREE.Line(f,x),a.add(l)}r.updateHoleInfo(E,L,b),m=!0,O()}window.loadHole=U;let Z=0;function K(){requestAnimationFrame(K);try{if(D)return;if(!a||!g||!c){console.error("Missing critical component:",{scene:!!a,camera:!!g,renderer:!!c});return}if(e&&(e.update(1/60),ye()),ge(),s&&e&&e.ball){s.position.copy(e.ball.position);const t=e.ball.velocity.lengthSq()>.01;Y&&!t&&(console.log("Ball stopped moving, updating ideal power indicator"),r.updateIdealPowerIndicator()),Y=t,r&&(e.hole&&r.updateDistance(s.position,e.hole.position),e.wind&&(r.updateWind(e.wind.speed,e.wind.direction),S&&S.userData.animateFlag&&S.userData.animateFlag(e.wind.direction,e.wind.speed))),m&&l?((r.clubChanged||G)&&(O(),r.clubChanged=!1,G=!1),l.visible=!0):l&&(l.visible=!1)}e&&e.isBallInHole()&&fe(),s&&w&&w.update(s.position,e?e.ball.velocity:null,T,C),C&&r&&ce(),_&&r&&de(),a&&g&&c&&(c.setClearColor(8900331,1),c.clear(),c.render(a,g),Z%60,Z++)}catch(t){console.error("Error in animation loop:",t)}}function te(){g.aspect=window.innerWidth/window.innerHeight,g.updateProjectionMatrix(),c.setSize(window.innerWidth,window.innerHeight)}function oe(t){t.key===" "?!C&&!_?(C=!0,h=0,B=!0,m=!1,l&&(l.visible=!1)):_&&(_=!1,r.hideAccuracyBar(),ue()):t.key==="ArrowLeft"?(T+=.1,m=!0,G=!0):t.key==="ArrowRight"?(T-=.1,m=!0,G=!0):t.key==="Shift"&&(m=!0)}function ie(t){t.key===" "&&C?(C=!1,_=!0,v=0,I=!0,r.showAccuracyBar()):t.key==="Shift"&&(m=!1)}function ce(){B?(h+=.015,h>=1&&(h=1,B=!1)):(h-=.015,h<=0&&(h=0,B=!0)),r.updatePowerMeter(h)}function de(){I?(v+=X,v>=1&&(v=1,I=!1)):(v-=X,v<=0&&(v=0,I=!0)),r.updateAccuracyBar(v)}function ue(){if(D)return;m=!1,l&&(l.visible=!1);const t=r.getSelectedClub()||"driver",i=h*20,n=r.getAccuracyResult(v);let o=1,d=0;n==="perfect"?(o=1,d=0):n==="okay"?(o=.9,d=(Math.random()-.5)*.2):(o=.7,d=(Math.random()-.5)*.5);const f=i*o,x=T+d;b++,r.updateHoleInfo(E,L,b),e.ball.onGround=!0,e.ball.inAir=!1;const p=e.getTerrainHeightAt(e.ball.position.x,e.ball.position.z);e.ball.position.y=p+.1,s.position.copy(e.ball.position),e.calculateShot(f,x,t),h=0,r.updatePowerMeter(h)}function fe(){D=!0,a.remove(s),setTimeout(()=>{alert(`Hole ${E} completed in ${b} strokes!`),E++,b=0,T=0,r.updateHoleInfo(E,L,b),D=!1,me()},1e3),m=!1,l&&(l.visible=!1)}function pe(t,i,n){const o=[],f=e.clubStats[n]||e.clubStats.driver,x=Math.max(4,t*f.multiplier*1.5),p=Math.ceil(x/.1),P=THREE.MathUtils.degToRad(f.angle),k=t*25*f.multiplier,W=k*Math.cos(P),ne=k*Math.sin(P),M=new THREE.Vector3(W*Math.cos(i),ne,W*-Math.sin(i)),H=s.position.clone();o.push(H.clone());let F=!0,Q=!1,$=null;for(let A=0;A<p;A++){if(F){M.y-=e.gravity*.1;const y=H.clone();y.add(M.clone().multiplyScalar(.1));let j=0;try{j=e.getTerrainHeightAt(y.x,y.z)}catch{console.warn("Error getting terrain height in trajectory prediction")}y.y<=j&&(y.y=j,M.y*=-.3,$||($=y.clone()),Math.abs(M.y)<1&&(F=!1,Q=!0)),H.copy(y)}else if(Q){if(M.multiplyScalar(1-.15),M.length()<.2)break;H.add(M.clone().multiplyScalar(.1));try{H.y=e.getTerrainHeightAt(H.x,H.z)}catch{}}o.push(H.clone())}if(F&&!$){const A=H.clone();try{const y=e.getTerrainHeightAt(A.x,A.z);A.y=y,o.push(A)}catch{console.warn("Error projecting trajectory end point to terrain")}}return o}function O(){try{if(!l||!s||!e||!r){console.warn("Cannot update trajectory line: required components not initialized");return}const i=pe(.7,T,r.getSelectedClub());if(!i||i.length<2){console.warn("Invalid trajectory points generated");return}const n=new Float32Array(i.length*3);for(let o=0,d=0;o<i.length;o++,d+=3){const f=i[o];n[d]=f.x,n[d+1]=f.y,n[d+2]=f.z}l.geometry.dispose(),l.geometry=new THREE.BufferGeometry,l.geometry.setAttribute("position",new THREE.BufferAttribute(n,3)),l.computeLineDistances(),l.visible=!0}catch(t){console.error("Error updating trajectory:",t)}}function ge(){e&&s&&!C&&!_&&e.ball.velocity&&e.ball.velocity.length()<.1&&(m||(console.log("Ball stopped, entering aiming mode"),m=!0,l&&(l.visible=!0),O()))}function me(){s=R.createBall();const t=new THREE.Vector3(-250,u.getHeightAt(-250,0)+.5,0);s.position.copy(t);const i=new THREE.Vector3(-8,8,0);w.targetPosition.copy(t).add(i),w.targetLookAt.set(250,u.getHeightAt(250,0)+.5,0),e.ball.position.copy(s.position),e.ball.velocity.set(0,0,0),e.ball.inAir=!1,e.ball.onGround=!0,console.log("Ball reset to:",s.position),m=!0,O()}function ye(){if(!q&&e.ball&&u){const t=holeConfigs[E],i=new THREE.Vector3(t.green.x,0,t.green.z),n=e.ball.position,o=n.x-i.x,d=n.z-i.z;Math.sqrt(o*o+d*d)<.5&&Math.abs(n.y-u.getHeightAt(i.x,i.z))<.5&&(q=!0,console.log(`Hole ${E} completed in ${b} strokes`),V=setTimeout(()=>{E<Object.keys(holeConfigs).length?U(E+1):r.showGameComplete(b)},2e3))}}export{ae as loadModules};
